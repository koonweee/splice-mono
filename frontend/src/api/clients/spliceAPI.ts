/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Splice API
 * Financial account management API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Account,
  AccountWithConvertedBalance,
  BalanceSnapshot,
  BalanceSnapshotWithConvertedBalance,
  CreateAccountDto,
  CreateBalanceSnapshotDto,
  CreateTransactionDto,
  CreateUserDto,
  DashboardControllerGetSummaryParams,
  DashboardSummary,
  ExchangeRate,
  ExchangeRateControllerGetLatestRate200,
  ExchangeRateControllerGetRate200,
  ExchangeRateControllerGetRateParams,
  ExchangeRateControllerGetRatesForDateParams,
  InitiateLinkRequest,
  InitiateLinkResponse,
  LoginDto,
  LoginResponse,
  RefreshTokenDto,
  TokenResponse,
  Transaction,
  TransactionControllerFindAllParams,
  UpdateBalanceSnapshotDto,
  UpdateTransactionDto,
  UpdateUserSettingsDto,
  User,
  UserSettings
} from '../models';

import { axios } from '../axios';




/**
 * Get all accounts with converted balances
 */
export const accountControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<AccountWithConvertedBalance[]>(
      {url: `/account`, method: 'GET', signal
    },
      );
    }
  



export const getAccountControllerFindAllQueryKey = () => {
    return [
    `/account`
    ] as const;
    }

    
export const getAccountControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountControllerFindAll>>> = ({ signal }) => accountControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AccountControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof accountControllerFindAll>>>
export type AccountControllerFindAllQueryError = unknown


export function useAccountControllerFindAll<TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof accountControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountControllerFindAll<TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof accountControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountControllerFindAll<TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAccountControllerFindAll<TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAccountControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new account
 */
export const accountControllerCreate = (
    createAccountDto: CreateAccountDto,
 signal?: AbortSignal
) => {
      
      
      return axios<AccountWithConvertedBalance>(
      {url: `/account`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAccountDto, signal
    },
      );
    }
  


export const getAccountControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext> => {

const mutationKey = ['accountControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountControllerCreate>>, {data: CreateAccountDto}> = (props) => {
          const {data} = props ?? {};

          return  accountControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accountControllerCreate>>>
    export type AccountControllerCreateMutationBody = CreateAccountDto
    export type AccountControllerCreateMutationError = unknown

    export const useAccountControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof accountControllerCreate>>,
        TError,
        {data: CreateAccountDto},
        TContext
      > => {

      const mutationOptions = getAccountControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get an account by ID with converted balances
 */
export const accountControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axios<AccountWithConvertedBalance>(
      {url: `/account/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getAccountControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/account/${id}`
    ] as const;
    }

    
export const getAccountControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountControllerFindOne>>> = ({ signal }) => accountControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AccountControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof accountControllerFindOne>>>
export type AccountControllerFindOneQueryError = void


export function useAccountControllerFindOne<TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof accountControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountControllerFindOne<TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof accountControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof accountControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAccountControllerFindOne<TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAccountControllerFindOne<TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAccountControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete an account
 */
export const accountControllerRemove = (
    id: string,
 ) => {
      
      
      return axios<void>(
      {url: `/account/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getAccountControllerRemoveMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['accountControllerRemove'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  accountControllerRemove(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof accountControllerRemove>>>
    
    export type AccountControllerRemoveMutationError = void

    export const useAccountControllerRemove = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof accountControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getAccountControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Register a new user
 */
export const userControllerRegister = (
    createUserDto: CreateUserDto,
 signal?: AbortSignal
) => {
      
      
      return axios<User>(
      {url: `/user/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      );
    }
  


export const getUserControllerRegisterMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext> => {

const mutationKey = ['userControllerRegister'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerRegister>>, {data: CreateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerRegister(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerRegister>>>
    export type UserControllerRegisterMutationBody = CreateUserDto
    export type UserControllerRegisterMutationError = void

    export const useUserControllerRegister = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerRegister>>,
        TError,
        {data: CreateUserDto},
        TContext
      > => {

      const mutationOptions = getUserControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Login and get JWT token
 */
export const userControllerLogin = (
    loginDto: LoginDto,
 signal?: AbortSignal
) => {
      
      
      return axios<LoginResponse>(
      {url: `/user/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      );
    }
  


export const getUserControllerLoginMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['userControllerLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerLogin>>>
    export type UserControllerLoginMutationBody = LoginDto
    export type UserControllerLoginMutationError = void

    export const useUserControllerLogin = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getUserControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get current user profile
 */
export const userControllerMe = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<User>(
      {url: `/user/me`, method: 'GET', signal
    },
      );
    }
  



export const getUserControllerMeQueryKey = () => {
    return [
    `/user/me`
    ] as const;
    }

    
export const getUserControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof userControllerMe>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerMe>>> = ({ signal }) => userControllerMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerMe>>>
export type UserControllerMeQueryError = void


export function useUserControllerMe<TData = Awaited<ReturnType<typeof userControllerMe>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerMe<TData = Awaited<ReturnType<typeof userControllerMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerMe<TData = Awaited<ReturnType<typeof userControllerMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerMe<TData = Awaited<ReturnType<typeof userControllerMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update current user settings
 */
export const userControllerUpdateSettings = (
    updateUserSettingsDto: UpdateUserSettingsDto,
 ) => {
      
      
      return axios<UserSettings>(
      {url: `/user/settings`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserSettingsDto
    },
      );
    }
  


export const getUserControllerUpdateSettingsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateSettings>>, TError,{data: UpdateUserSettingsDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateSettings>>, TError,{data: UpdateUserSettingsDto}, TContext> => {

const mutationKey = ['userControllerUpdateSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdateSettings>>, {data: UpdateUserSettingsDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerUpdateSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdateSettings>>>
    export type UserControllerUpdateSettingsMutationBody = UpdateUserSettingsDto
    export type UserControllerUpdateSettingsMutationError = void

    export const useUserControllerUpdateSettings = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateSettings>>, TError,{data: UpdateUserSettingsDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdateSettings>>,
        TError,
        {data: UpdateUserSettingsDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Refresh access token using refresh token
 */
export const userControllerRefresh = (
    refreshTokenDto: RefreshTokenDto,
 signal?: AbortSignal
) => {
      
      
      return axios<TokenResponse>(
      {url: `/user/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenDto, signal
    },
      );
    }
  


export const getUserControllerRefreshMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext> => {

const mutationKey = ['userControllerRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerRefresh>>, {data: RefreshTokenDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerRefresh(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerRefresh>>>
    export type UserControllerRefreshMutationBody = RefreshTokenDto
    export type UserControllerRefreshMutationError = void

    export const useUserControllerRefresh = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerRefresh>>,
        TError,
        {data: RefreshTokenDto},
        TContext
      > => {

      const mutationOptions = getUserControllerRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Logout and invalidate refresh token
 */
export const userControllerLogout = (
    refreshTokenDto: RefreshTokenDto,
 signal?: AbortSignal
) => {
      
      
      return axios<void>(
      {url: `/user/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenDto, signal
    },
      );
    }
  


export const getUserControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogout>>, TError,{data: RefreshTokenDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerLogout>>, TError,{data: RefreshTokenDto}, TContext> => {

const mutationKey = ['userControllerLogout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerLogout>>, {data: RefreshTokenDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerLogout(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerLogout>>>
    export type UserControllerLogoutMutationBody = RefreshTokenDto
    export type UserControllerLogoutMutationError = unknown

    export const useUserControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogout>>, TError,{data: RefreshTokenDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerLogout>>,
        TError,
        {data: RefreshTokenDto},
        TContext
      > => {

      const mutationOptions = getUserControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Logout from all devices
 */
export const userControllerLogoutAll = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<void>(
      {url: `/user/logout-all`, method: 'POST', signal
    },
      );
    }
  


export const getUserControllerLogoutAllMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogoutAll>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerLogoutAll>>, TError,void, TContext> => {

const mutationKey = ['userControllerLogoutAll'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerLogoutAll>>, void> = () => {
          

          return  userControllerLogoutAll()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerLogoutAllMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerLogoutAll>>>
    
    export type UserControllerLogoutAllMutationError = unknown

    export const useUserControllerLogoutAll = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogoutAll>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerLogoutAll>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUserControllerLogoutAllMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Manually trigger exchange rate sync for all required currency pairs
 */
export const exchangeRateControllerSyncRates = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<ExchangeRate[]>(
      {url: `/exchange-rates/sync`, method: 'POST', signal
    },
      );
    }
  


export const getExchangeRateControllerSyncRatesMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>, TError,void, TContext> => {

const mutationKey = ['exchangeRateControllerSyncRates'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>, void> = () => {
          

          return  exchangeRateControllerSyncRates()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExchangeRateControllerSyncRatesMutationResult = NonNullable<Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>>
    
    export type ExchangeRateControllerSyncRatesMutationError = void

    export const useExchangeRateControllerSyncRates = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof exchangeRateControllerSyncRates>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getExchangeRateControllerSyncRatesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get the latest exchange rate for a currency pair
 */
export const exchangeRateControllerGetLatestRate = (
    baseCurrency: string,
    targetCurrency: string,
 signal?: AbortSignal
) => {
      
      
      return axios<ExchangeRateControllerGetLatestRate200>(
      {url: `/exchange-rates/latest/${baseCurrency}/${targetCurrency}`, method: 'GET', signal
    },
      );
    }
  



export const getExchangeRateControllerGetLatestRateQueryKey = (baseCurrency?: string,
    targetCurrency?: string,) => {
    return [
    `/exchange-rates/latest/${baseCurrency}/${targetCurrency}`
    ] as const;
    }

    
export const getExchangeRateControllerGetLatestRateQueryOptions = <TData = Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError = unknown>(baseCurrency: string,
    targetCurrency: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExchangeRateControllerGetLatestRateQueryKey(baseCurrency,targetCurrency);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>> = ({ signal }) => exchangeRateControllerGetLatestRate(baseCurrency,targetCurrency, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(baseCurrency && targetCurrency), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExchangeRateControllerGetLatestRateQueryResult = NonNullable<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>>
export type ExchangeRateControllerGetLatestRateQueryError = unknown


export function useExchangeRateControllerGetLatestRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetLatestRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetLatestRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExchangeRateControllerGetLatestRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetLatestRate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExchangeRateControllerGetLatestRateQueryOptions(baseCurrency,targetCurrency,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get exchange rate for a currency pair on a specific date
 */
export const exchangeRateControllerGetRate = (
    baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams,
 signal?: AbortSignal
) => {
      
      
      return axios<ExchangeRateControllerGetRate200>(
      {url: `/exchange-rates/${baseCurrency}/${targetCurrency}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getExchangeRateControllerGetRateQueryKey = (baseCurrency?: string,
    targetCurrency?: string,
    params?: ExchangeRateControllerGetRateParams,) => {
    return [
    `/exchange-rates/${baseCurrency}/${targetCurrency}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getExchangeRateControllerGetRateQueryOptions = <TData = Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError = unknown>(baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExchangeRateControllerGetRateQueryKey(baseCurrency,targetCurrency,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>> = ({ signal }) => exchangeRateControllerGetRate(baseCurrency,targetCurrency,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(baseCurrency && targetCurrency), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExchangeRateControllerGetRateQueryResult = NonNullable<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>>
export type ExchangeRateControllerGetRateQueryError = unknown


export function useExchangeRateControllerGetRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetRate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetRate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetRate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetRate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExchangeRateControllerGetRate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError = unknown>(
 baseCurrency: string,
    targetCurrency: string,
    params: ExchangeRateControllerGetRateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExchangeRateControllerGetRateQueryOptions(baseCurrency,targetCurrency,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all exchange rates for a specific date
 */
export const exchangeRateControllerGetRatesForDate = (
    params: ExchangeRateControllerGetRatesForDateParams,
 signal?: AbortSignal
) => {
      
      
      return axios<ExchangeRate[]>(
      {url: `/exchange-rates`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getExchangeRateControllerGetRatesForDateQueryKey = (params?: ExchangeRateControllerGetRatesForDateParams,) => {
    return [
    `/exchange-rates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getExchangeRateControllerGetRatesForDateQueryOptions = <TData = Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError = unknown>(params: ExchangeRateControllerGetRatesForDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExchangeRateControllerGetRatesForDateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>> = ({ signal }) => exchangeRateControllerGetRatesForDate(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExchangeRateControllerGetRatesForDateQueryResult = NonNullable<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>>
export type ExchangeRateControllerGetRatesForDateQueryError = unknown


export function useExchangeRateControllerGetRatesForDate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError = unknown>(
 params: ExchangeRateControllerGetRatesForDateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetRatesForDate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError = unknown>(
 params: ExchangeRateControllerGetRatesForDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>,
          TError,
          Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExchangeRateControllerGetRatesForDate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError = unknown>(
 params: ExchangeRateControllerGetRatesForDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExchangeRateControllerGetRatesForDate<TData = Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError = unknown>(
 params: ExchangeRateControllerGetRatesForDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exchangeRateControllerGetRatesForDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExchangeRateControllerGetRatesForDateQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all balance snapshots with converted balances
 */
export const balanceSnapshotControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<BalanceSnapshotWithConvertedBalance[]>(
      {url: `/balance-snapshot`, method: 'GET', signal
    },
      );
    }
  



export const getBalanceSnapshotControllerFindAllQueryKey = () => {
    return [
    `/balance-snapshot`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>> = ({ signal }) => balanceSnapshotControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BalanceSnapshotControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>>
export type BalanceSnapshotControllerFindAllQueryError = unknown


export function useBalanceSnapshotControllerFindAll<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindAll<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindAll<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useBalanceSnapshotControllerFindAll<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBalanceSnapshotControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new balance snapshot
 */
export const balanceSnapshotControllerCreate = (
    createBalanceSnapshotDto: CreateBalanceSnapshotDto,
 signal?: AbortSignal
) => {
      
      
      return axios<BalanceSnapshot>(
      {url: `/balance-snapshot`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBalanceSnapshotDto, signal
    },
      );
    }
  


export const getBalanceSnapshotControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext> => {

const mutationKey = ['balanceSnapshotControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, {data: CreateBalanceSnapshotDto}> = (props) => {
          const {data} = props ?? {};

          return  balanceSnapshotControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>>
    export type BalanceSnapshotControllerCreateMutationBody = CreateBalanceSnapshotDto
    export type BalanceSnapshotControllerCreateMutationError = unknown

    export const useBalanceSnapshotControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>,
        TError,
        {data: CreateBalanceSnapshotDto},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get a balance snapshot by ID
 */
export const balanceSnapshotControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axios<BalanceSnapshot>(
      {url: `/balance-snapshot/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getBalanceSnapshotControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/balance-snapshot/${id}`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>> = ({ signal }) => balanceSnapshotControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BalanceSnapshotControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>>
export type BalanceSnapshotControllerFindOneQueryError = void


export function useBalanceSnapshotControllerFindOne<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindOne<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindOne<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useBalanceSnapshotControllerFindOne<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBalanceSnapshotControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a balance snapshot
 */
export const balanceSnapshotControllerUpdate = (
    id: string,
    updateBalanceSnapshotDto: UpdateBalanceSnapshotDto,
 ) => {
      
      
      return axios<BalanceSnapshot>(
      {url: `/balance-snapshot/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateBalanceSnapshotDto
    },
      );
    }
  


export const getBalanceSnapshotControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext> => {

const mutationKey = ['balanceSnapshotControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, {id: string;data: UpdateBalanceSnapshotDto}> = (props) => {
          const {id,data} = props ?? {};

          return  balanceSnapshotControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>>
    export type BalanceSnapshotControllerUpdateMutationBody = UpdateBalanceSnapshotDto
    export type BalanceSnapshotControllerUpdateMutationError = void

    export const useBalanceSnapshotControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>,
        TError,
        {id: string;data: UpdateBalanceSnapshotDto},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a balance snapshot
 */
export const balanceSnapshotControllerRemove = (
    id: string,
 ) => {
      
      
      return axios<void>(
      {url: `/balance-snapshot/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getBalanceSnapshotControllerRemoveMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['balanceSnapshotControllerRemove'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  balanceSnapshotControllerRemove(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>>
    
    export type BalanceSnapshotControllerRemoveMutationError = void

    export const useBalanceSnapshotControllerRemove = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all balance snapshots for an account with converted balances
 */
export const balanceSnapshotControllerFindByAccountId = (
    accountId: string,
 signal?: AbortSignal
) => {
      
      
      return axios<BalanceSnapshotWithConvertedBalance[]>(
      {url: `/balance-snapshot/account/${accountId}`, method: 'GET', signal
    },
      );
    }
  



export const getBalanceSnapshotControllerFindByAccountIdQueryKey = (accountId?: string,) => {
    return [
    `/balance-snapshot/account/${accountId}`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindByAccountIdQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = unknown>(accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindByAccountIdQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>> = ({ signal }) => balanceSnapshotControllerFindByAccountId(accountId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BalanceSnapshotControllerFindByAccountIdQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>>
export type BalanceSnapshotControllerFindByAccountIdQueryError = unknown


export function useBalanceSnapshotControllerFindByAccountId<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = unknown>(
 accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindByAccountId<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = unknown>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>,
          TError,
          Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBalanceSnapshotControllerFindByAccountId<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = unknown>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useBalanceSnapshotControllerFindByAccountId<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = unknown>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBalanceSnapshotControllerFindByAccountIdQueryOptions(accountId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Initiate bank account linking with specified provider
 */
export const bankLinkControllerInitiateLinking = (
    provider: string,
    initiateLinkRequest: InitiateLinkRequest,
 signal?: AbortSignal
) => {
      
      
      return axios<InitiateLinkResponse>(
      {url: `/bank-link/initiate/${provider}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: initiateLinkRequest, signal
    },
      );
    }
  


export const getBankLinkControllerInitiateLinkingMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext> => {

const mutationKey = ['bankLinkControllerInitiateLinking'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, {provider: string;data: InitiateLinkRequest}> = (props) => {
          const {provider,data} = props ?? {};

          return  bankLinkControllerInitiateLinking(provider,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerInitiateLinkingMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>>
    export type BankLinkControllerInitiateLinkingMutationBody = InitiateLinkRequest
    export type BankLinkControllerInitiateLinkingMutationError = void

    export const useBankLinkControllerInitiateLinking = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>,
        TError,
        {provider: string;data: InitiateLinkRequest},
        TContext
      > => {

      const mutationOptions = getBankLinkControllerInitiateLinkingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Handle webhook from provider (called by external service)
 */
export const bankLinkControllerHandleWebhook = (
    provider: string,
 signal?: AbortSignal
) => {
      
      
      return axios<void>(
      {url: `/bank-link/webhook/${provider}`, method: 'POST', signal
    },
      );
    }
  


export const getBankLinkControllerHandleWebhookMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext> => {

const mutationKey = ['bankLinkControllerHandleWebhook'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, {provider: string}> = (props) => {
          const {provider} = props ?? {};

          return  bankLinkControllerHandleWebhook(provider,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerHandleWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>>
    
    export type BankLinkControllerHandleWebhookMutationError = void

    export const useBankLinkControllerHandleWebhook = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>,
        TError,
        {provider: string},
        TContext
      > => {

      const mutationOptions = getBankLinkControllerHandleWebhookMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Sync accounts for all bank links
 */
export const bankLinkControllerSyncAllAccounts = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<Account[]>(
      {url: `/bank-link/sync-all`, method: 'POST', signal
    },
      );
    }
  


export const getBankLinkControllerSyncAllAccountsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext> => {

const mutationKey = ['bankLinkControllerSyncAllAccounts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, void> = () => {
          

          return  bankLinkControllerSyncAllAccounts()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerSyncAllAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>>
    
    export type BankLinkControllerSyncAllAccountsMutationError = unknown

    export const useBankLinkControllerSyncAllAccounts = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getBankLinkControllerSyncAllAccountsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Backfill Plaid item IDs for existing bank links that are missing them
 */
export const bankLinkControllerBackfillPlaidItemIds = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<void>(
      {url: `/bank-link/backfill-item-ids`, method: 'POST', signal
    },
      );
    }
  


export const getBankLinkControllerBackfillPlaidItemIdsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>, TError,void, TContext> => {

const mutationKey = ['bankLinkControllerBackfillPlaidItemIds'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>, void> = () => {
          

          return  bankLinkControllerBackfillPlaidItemIds()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerBackfillPlaidItemIdsMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>>
    
    export type BankLinkControllerBackfillPlaidItemIdsMutationError = unknown

    export const useBankLinkControllerBackfillPlaidItemIds = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerBackfillPlaidItemIds>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getBankLinkControllerBackfillPlaidItemIdsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get dashboard summary with net worth and account summaries
 */
export const dashboardControllerGetSummary = (
    params?: DashboardControllerGetSummaryParams,
 signal?: AbortSignal
) => {
      
      
      return axios<DashboardSummary>(
      {url: `/dashboard/summary`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getDashboardControllerGetSummaryQueryKey = (params?: DashboardControllerGetSummaryParams,) => {
    return [
    `/dashboard/summary`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getDashboardControllerGetSummaryQueryOptions = <TData = Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError = unknown>(params?: DashboardControllerGetSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardControllerGetSummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardControllerGetSummary>>> = ({ signal }) => dashboardControllerGetSummary(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DashboardControllerGetSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardControllerGetSummary>>>
export type DashboardControllerGetSummaryQueryError = unknown


export function useDashboardControllerGetSummary<TData = Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError = unknown>(
 params: undefined |  DashboardControllerGetSummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerGetSummary>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerGetSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDashboardControllerGetSummary<TData = Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError = unknown>(
 params?: DashboardControllerGetSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerGetSummary>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerGetSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDashboardControllerGetSummary<TData = Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError = unknown>(
 params?: DashboardControllerGetSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDashboardControllerGetSummary<TData = Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError = unknown>(
 params?: DashboardControllerGetSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerGetSummary>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDashboardControllerGetSummaryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all transactions
 */
export const transactionControllerFindAll = (
    params?: TransactionControllerFindAllParams,
 signal?: AbortSignal
) => {
      
      
      return axios<Transaction[]>(
      {url: `/transaction`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getTransactionControllerFindAllQueryKey = (params?: TransactionControllerFindAllParams,) => {
    return [
    `/transaction`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTransactionControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = unknown>(params?: TransactionControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerFindAll>>> = ({ signal }) => transactionControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TransactionControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerFindAll>>>
export type TransactionControllerFindAllQueryError = unknown


export function useTransactionControllerFindAll<TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = unknown>(
 params: undefined |  TransactionControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionControllerFindAll<TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = unknown>(
 params?: TransactionControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionControllerFindAll<TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = unknown>(
 params?: TransactionControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTransactionControllerFindAll<TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = unknown>(
 params?: TransactionControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTransactionControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new transaction
 */
export const transactionControllerCreate = (
    createTransactionDto: CreateTransactionDto,
 signal?: AbortSignal
) => {
      
      
      return axios<Transaction>(
      {url: `/transaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTransactionDto, signal
    },
      );
    }
  


export const getTransactionControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext> => {

const mutationKey = ['transactionControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerCreate>>, {data: CreateTransactionDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerCreate>>>
    export type TransactionControllerCreateMutationBody = CreateTransactionDto
    export type TransactionControllerCreateMutationError = unknown

    export const useTransactionControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerCreate>>,
        TError,
        {data: CreateTransactionDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get a transaction by ID
 */
export const transactionControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axios<Transaction>(
      {url: `/transaction/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getTransactionControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/transaction/${id}`
    ] as const;
    }

    
export const getTransactionControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerFindOne>>> = ({ signal }) => transactionControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TransactionControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerFindOne>>>
export type TransactionControllerFindOneQueryError = void


export function useTransactionControllerFindOne<TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionControllerFindOne<TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionControllerFindOne<TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTransactionControllerFindOne<TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTransactionControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a transaction
 */
export const transactionControllerUpdate = (
    id: string,
    updateTransactionDto: UpdateTransactionDto,
 ) => {
      
      
      return axios<Transaction>(
      {url: `/transaction/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTransactionDto
    },
      );
    }
  


export const getTransactionControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext> => {

const mutationKey = ['transactionControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerUpdate>>, {id: string;data: UpdateTransactionDto}> = (props) => {
          const {id,data} = props ?? {};

          return  transactionControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerUpdate>>>
    export type TransactionControllerUpdateMutationBody = UpdateTransactionDto
    export type TransactionControllerUpdateMutationError = void

    export const useTransactionControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerUpdate>>,
        TError,
        {id: string;data: UpdateTransactionDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a transaction
 */
export const transactionControllerRemove = (
    id: string,
 ) => {
      
      
      return axios<void>(
      {url: `/transaction/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getTransactionControllerRemoveMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['transactionControllerRemove'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  transactionControllerRemove(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerRemove>>>
    
    export type TransactionControllerRemoveMutationError = void

    export const useTransactionControllerRemove = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTransactionControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
