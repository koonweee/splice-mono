/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Splice API
 * Financial account management API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  Account,
  BalanceSnapshot,
  CreateAccountDto,
  CreateBalanceSnapshotDto,
  CreateTransactionDto,
  CreateUserDto,
  InitiateLinkRequest,
  InitiateLinkResponse,
  LoginDto,
  LoginResponse,
  Transaction,
  TransactionControllerFindAllParams,
  UpdateBalanceSnapshotDto,
  UpdateTransactionDto,
  User
} from '../models';





/**
 * Get all accounts
 */
export const accountControllerFindAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account[]>> => {
    
    
    return axios.default.get(
      `/account`,options
    );
  }




export const getAccountControllerFindAllQueryKey = () => {
    return [
    `/account`
    ] as const;
    }

    
export const getAccountControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountControllerFindAll>>> = ({ signal }) => accountControllerFindAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData> & { queryKey: QueryKey }
}

export type AccountControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof accountControllerFindAll>>>
export type AccountControllerFindAllQueryError = AxiosError<unknown>



export function useAccountControllerFindAll<TData = Awaited<ReturnType<typeof accountControllerFindAll>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAccountControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new account
 */
export const accountControllerCreate = (
    createAccountDto: CreateAccountDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account>> => {
    
    
    return axios.default.post(
      `/account`,
      createAccountDto,options
    );
  }



export const getAccountControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext> => {

const mutationKey = ['accountControllerCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountControllerCreate>>, {data: CreateAccountDto}> = (props) => {
          const {data} = props ?? {};

          return  accountControllerCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accountControllerCreate>>>
    export type AccountControllerCreateMutationBody = CreateAccountDto
    export type AccountControllerCreateMutationError = AxiosError<unknown>

    export const useAccountControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerCreate>>, TError,{data: CreateAccountDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof accountControllerCreate>>,
        TError,
        {data: CreateAccountDto},
        TContext
      > => {

      const mutationOptions = getAccountControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get an account by ID
 */
export const accountControllerFindOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account>> => {
    
    
    return axios.default.get(
      `/account/${id}`,options
    );
  }




export const getAccountControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/account/${id}`
    ] as const;
    }

    
export const getAccountControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = AxiosError<void>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountControllerFindOne>>> = ({ signal }) => accountControllerFindOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData> & { queryKey: QueryKey }
}

export type AccountControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof accountControllerFindOne>>>
export type AccountControllerFindOneQueryError = AxiosError<void>



export function useAccountControllerFindOne<TData = Awaited<ReturnType<typeof accountControllerFindOne>>, TError = AxiosError<void>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAccountControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete an account
 */
export const accountControllerRemove = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/account/${id}`,options
    );
  }



export const getAccountControllerRemoveMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['accountControllerRemove'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  accountControllerRemove(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccountControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof accountControllerRemove>>>
    
    export type AccountControllerRemoveMutationError = AxiosError<void>

    export const useAccountControllerRemove = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accountControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof accountControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getAccountControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get all balance snapshots
 */
export const balanceSnapshotControllerFindAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BalanceSnapshot[]>> => {
    
    
    return axios.default.get(
      `/balance-snapshot`,options
    );
  }




export const getBalanceSnapshotControllerFindAllQueryKey = () => {
    return [
    `/balance-snapshot`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>> = ({ signal }) => balanceSnapshotControllerFindAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData> & { queryKey: QueryKey }
}

export type BalanceSnapshotControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>>
export type BalanceSnapshotControllerFindAllQueryError = AxiosError<unknown>



export function useBalanceSnapshotControllerFindAll<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBalanceSnapshotControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new balance snapshot
 */
export const balanceSnapshotControllerCreate = (
    createBalanceSnapshotDto: CreateBalanceSnapshotDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BalanceSnapshot>> => {
    
    
    return axios.default.post(
      `/balance-snapshot`,
      createBalanceSnapshotDto,options
    );
  }



export const getBalanceSnapshotControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext> => {

const mutationKey = ['balanceSnapshotControllerCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, {data: CreateBalanceSnapshotDto}> = (props) => {
          const {data} = props ?? {};

          return  balanceSnapshotControllerCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>>
    export type BalanceSnapshotControllerCreateMutationBody = CreateBalanceSnapshotDto
    export type BalanceSnapshotControllerCreateMutationError = AxiosError<unknown>

    export const useBalanceSnapshotControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>, TError,{data: CreateBalanceSnapshotDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerCreate>>,
        TError,
        {data: CreateBalanceSnapshotDto},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get a balance snapshot by ID
 */
export const balanceSnapshotControllerFindOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BalanceSnapshot>> => {
    
    
    return axios.default.get(
      `/balance-snapshot/${id}`,options
    );
  }




export const getBalanceSnapshotControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/balance-snapshot/${id}`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = AxiosError<void>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>> = ({ signal }) => balanceSnapshotControllerFindOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData> & { queryKey: QueryKey }
}

export type BalanceSnapshotControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>>
export type BalanceSnapshotControllerFindOneQueryError = AxiosError<void>



export function useBalanceSnapshotControllerFindOne<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError = AxiosError<void>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBalanceSnapshotControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a balance snapshot
 */
export const balanceSnapshotControllerUpdate = (
    id: string,
    updateBalanceSnapshotDto: UpdateBalanceSnapshotDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BalanceSnapshot>> => {
    
    
    return axios.default.patch(
      `/balance-snapshot/${id}`,
      updateBalanceSnapshotDto,options
    );
  }



export const getBalanceSnapshotControllerUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext> => {

const mutationKey = ['balanceSnapshotControllerUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, {id: string;data: UpdateBalanceSnapshotDto}> = (props) => {
          const {id,data} = props ?? {};

          return  balanceSnapshotControllerUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>>
    export type BalanceSnapshotControllerUpdateMutationBody = UpdateBalanceSnapshotDto
    export type BalanceSnapshotControllerUpdateMutationError = AxiosError<void>

    export const useBalanceSnapshotControllerUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>, TError,{id: string;data: UpdateBalanceSnapshotDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerUpdate>>,
        TError,
        {id: string;data: UpdateBalanceSnapshotDto},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a balance snapshot
 */
export const balanceSnapshotControllerRemove = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/balance-snapshot/${id}`,options
    );
  }



export const getBalanceSnapshotControllerRemoveMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['balanceSnapshotControllerRemove'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  balanceSnapshotControllerRemove(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BalanceSnapshotControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>>
    
    export type BalanceSnapshotControllerRemoveMutationError = AxiosError<void>

    export const useBalanceSnapshotControllerRemove = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof balanceSnapshotControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getBalanceSnapshotControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get all balance snapshots for an account
 */
export const balanceSnapshotControllerFindByAccountId = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BalanceSnapshot[]>> => {
    
    
    return axios.default.get(
      `/balance-snapshot/account/${accountId}`,options
    );
  }




export const getBalanceSnapshotControllerFindByAccountIdQueryKey = (accountId?: string,) => {
    return [
    `/balance-snapshot/account/${accountId}`
    ] as const;
    }

    
export const getBalanceSnapshotControllerFindByAccountIdQueryOptions = <TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = AxiosError<unknown>>(accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBalanceSnapshotControllerFindByAccountIdQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>> = ({ signal }) => balanceSnapshotControllerFindByAccountId(accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData> & { queryKey: QueryKey }
}

export type BalanceSnapshotControllerFindByAccountIdQueryResult = NonNullable<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>>
export type BalanceSnapshotControllerFindByAccountIdQueryError = AxiosError<unknown>



export function useBalanceSnapshotControllerFindByAccountId<TData = Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError = AxiosError<unknown>>(
 accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof balanceSnapshotControllerFindByAccountId>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBalanceSnapshotControllerFindByAccountIdQueryOptions(accountId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Initiate bank account linking with specified provider
 */
export const bankLinkControllerInitiateLinking = (
    provider: string,
    initiateLinkRequest: InitiateLinkRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InitiateLinkResponse>> => {
    
    
    return axios.default.post(
      `/bank-link/initiate/${provider}`,
      initiateLinkRequest,options
    );
  }



export const getBankLinkControllerInitiateLinkingMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext> => {

const mutationKey = ['bankLinkControllerInitiateLinking'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, {provider: string;data: InitiateLinkRequest}> = (props) => {
          const {provider,data} = props ?? {};

          return  bankLinkControllerInitiateLinking(provider,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerInitiateLinkingMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>>
    export type BankLinkControllerInitiateLinkingMutationBody = InitiateLinkRequest
    export type BankLinkControllerInitiateLinkingMutationError = AxiosError<void>

    export const useBankLinkControllerInitiateLinking = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>, TError,{provider: string;data: InitiateLinkRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerInitiateLinking>>,
        TError,
        {provider: string;data: InitiateLinkRequest},
        TContext
      > => {

      const mutationOptions = getBankLinkControllerInitiateLinkingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Handle webhook from provider (called by external service)
 */
export const bankLinkControllerHandleWebhook = (
    provider: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/bank-link/webhook/${provider}`,undefined,options
    );
  }



export const getBankLinkControllerHandleWebhookMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext> => {

const mutationKey = ['bankLinkControllerHandleWebhook'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, {provider: string}> = (props) => {
          const {provider} = props ?? {};

          return  bankLinkControllerHandleWebhook(provider,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerHandleWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>>
    
    export type BankLinkControllerHandleWebhookMutationError = AxiosError<void>

    export const useBankLinkControllerHandleWebhook = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>, TError,{provider: string}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerHandleWebhook>>,
        TError,
        {provider: string},
        TContext
      > => {

      const mutationOptions = getBankLinkControllerHandleWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Sync accounts for all bank links
 */
export const bankLinkControllerSyncAllAccounts = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account[]>> => {
    
    
    return axios.default.post(
      `/bank-link/sync-all`,undefined,options
    );
  }



export const getBankLinkControllerSyncAllAccountsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext> => {

const mutationKey = ['bankLinkControllerSyncAllAccounts'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, void> = () => {
          

          return  bankLinkControllerSyncAllAccounts(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BankLinkControllerSyncAllAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>>
    
    export type BankLinkControllerSyncAllAccountsMutationError = AxiosError<unknown>

    export const useBankLinkControllerSyncAllAccounts = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof bankLinkControllerSyncAllAccounts>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getBankLinkControllerSyncAllAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Register a new user
 */
export const userControllerRegister = (
    createUserDto: CreateUserDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.post(
      `/user/register`,
      createUserDto,options
    );
  }



export const getUserControllerRegisterMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext> => {

const mutationKey = ['userControllerRegister'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerRegister>>, {data: CreateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerRegister(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerRegister>>>
    export type UserControllerRegisterMutationBody = CreateUserDto
    export type UserControllerRegisterMutationError = AxiosError<void>

    export const useUserControllerRegister = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerRegister>>, TError,{data: CreateUserDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof userControllerRegister>>,
        TError,
        {data: CreateUserDto},
        TContext
      > => {

      const mutationOptions = getUserControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Login and get JWT token
 */
export const userControllerLogin = (
    loginDto: LoginDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginResponse>> => {
    
    
    return axios.default.post(
      `/user/login`,
      loginDto,options
    );
  }



export const getUserControllerLoginMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['userControllerLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerLogin>>>
    export type UserControllerLoginMutationBody = LoginDto
    export type UserControllerLoginMutationError = AxiosError<void>

    export const useUserControllerLogin = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerLogin>>, TError,{data: LoginDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof userControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getUserControllerLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get current user profile
 */
export const userControllerMe = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.get(
      `/user/me`,options
    );
  }




export const getUserControllerMeQueryKey = () => {
    return [
    `/user/me`
    ] as const;
    }

    
export const getUserControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof userControllerMe>>, TError = AxiosError<void>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerMe>>> = ({ signal }) => userControllerMe({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData> & { queryKey: QueryKey }
}

export type UserControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerMe>>>
export type UserControllerMeQueryError = AxiosError<void>



export function useUserControllerMe<TData = Awaited<ReturnType<typeof userControllerMe>>, TError = AxiosError<void>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof userControllerMe>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getUserControllerMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all transactions
 */
export const transactionControllerFindAll = (
    params?: TransactionControllerFindAllParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction[]>> => {
    
    
    return axios.default.get(
      `/transaction`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getTransactionControllerFindAllQueryKey = (params?: TransactionControllerFindAllParams,) => {
    return [
    `/transaction`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTransactionControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = AxiosError<unknown>>(params?: TransactionControllerFindAllParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerFindAll>>> = ({ signal }) => transactionControllerFindAll(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerFindAll>>>
export type TransactionControllerFindAllQueryError = AxiosError<unknown>



export function useTransactionControllerFindAll<TData = Awaited<ReturnType<typeof transactionControllerFindAll>>, TError = AxiosError<unknown>>(
 params?: TransactionControllerFindAllParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindAll>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new transaction
 */
export const transactionControllerCreate = (
    createTransactionDto: CreateTransactionDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction>> => {
    
    
    return axios.default.post(
      `/transaction`,
      createTransactionDto,options
    );
  }



export const getTransactionControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext> => {

const mutationKey = ['transactionControllerCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerCreate>>, {data: CreateTransactionDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerCreate>>>
    export type TransactionControllerCreateMutationBody = CreateTransactionDto
    export type TransactionControllerCreateMutationError = AxiosError<unknown>

    export const useTransactionControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerCreate>>, TError,{data: CreateTransactionDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerCreate>>,
        TError,
        {data: CreateTransactionDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get a transaction by ID
 */
export const transactionControllerFindOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction>> => {
    
    
    return axios.default.get(
      `/transaction/${id}`,options
    );
  }




export const getTransactionControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/transaction/${id}`
    ] as const;
    }

    
export const getTransactionControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = AxiosError<void>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerFindOne>>> = ({ signal }) => transactionControllerFindOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerFindOne>>>
export type TransactionControllerFindOneQueryError = AxiosError<void>



export function useTransactionControllerFindOne<TData = Awaited<ReturnType<typeof transactionControllerFindOne>>, TError = AxiosError<void>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFindOne>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a transaction
 */
export const transactionControllerUpdate = (
    id: string,
    updateTransactionDto: UpdateTransactionDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction>> => {
    
    
    return axios.default.patch(
      `/transaction/${id}`,
      updateTransactionDto,options
    );
  }



export const getTransactionControllerUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext> => {

const mutationKey = ['transactionControllerUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerUpdate>>, {id: string;data: UpdateTransactionDto}> = (props) => {
          const {id,data} = props ?? {};

          return  transactionControllerUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerUpdate>>>
    export type TransactionControllerUpdateMutationBody = UpdateTransactionDto
    export type TransactionControllerUpdateMutationError = AxiosError<void>

    export const useTransactionControllerUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerUpdate>>, TError,{id: string;data: UpdateTransactionDto}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerUpdate>>,
        TError,
        {id: string;data: UpdateTransactionDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a transaction
 */
export const transactionControllerRemove = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/transaction/${id}`,options
    );
  }



export const getTransactionControllerRemoveMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['transactionControllerRemove'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  transactionControllerRemove(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerRemove>>>
    
    export type TransactionControllerRemoveMutationError = AxiosError<void>

    export const useTransactionControllerRemove = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTransactionControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
